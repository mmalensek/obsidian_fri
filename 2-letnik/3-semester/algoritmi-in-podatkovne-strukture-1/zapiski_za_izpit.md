### Napredno urejanje

1. <font color="#4bacc6">merge sort: </font>razdeli elemente seznama na prvo in drugo polovico, rekurzivno uredi vsako polovico na enak način, nato pa združi dva urejena seznama v skupen urejen seznam. Globina rekurzije je $O(\log n)$, ker sezba vsakič razdelimo na pol, za posamezen nivo pa potrebujemo $O(n)$ časa za združevanje. <font color="#4bacc6">Časovna zahtevnost</font> je zato vedno $O(n \log n)$. Da zmanjšamo prostorsko zahtevnost lahko uporabimo le pomožno tabelo za indekse in ne delamo kopij tabele.
2. <font color="#4bacc6">quick sort: </font>ta razdeli elemente seznama na majhne in velike, majhne da na začetek seznama, velike pa na konec, za število po katerem ločujemo izberemo naključen $pivot$, npr. prvi element seznama. Nato gremo čez seznam in delimo elemente seznama v tri skupine: manjše, večje in enake pivotu. V najslabšem primeru pridemo tako do $O(n^2)$ <font color="#4bacc6">časovne zahtevnosti</font>, a je še vedno v povprečju ta enaka $O(\log n)$. Prostorska zahtevnost pa je odvisna od implementacije od $O(\log n)$ do $O(n)$.
3. <font color="#4bacc6">heap sort: </font> ... izboljšava navadnega urejanja z izbiranjem, le da vedno znova iščeš najmanjši element samo med neurejenimi, ... (heap)
4. <font color="#4bacc6">counting sort: </font>ko imaš nabor različnih možnosti, ki ni velik (npr. poštne številke), kjer za vsako vrednost preštejemo kolikokrat se uporabi in jo na koncu temu primerno večkrat vnesemo v urejen seznam. Časovna zahtevnost je linearna ozr. $O(n + m)$, kjer je $m$ največja možna vrednost, neugodna pa je prostorska zahtevnost.
5. <font color="#4bacc6">bucket/bin sort</font> (mi pogledamo <font color="#4bacc6">radix sort</font>): osnovna ideja je, da razdeliš elemente seznama v koše glede na njihovo vrednost in rekurzivno dobimo nekaj podobnega $quicksortu$. Pogledamo si $radix \ sort$ ozr. <font color="#4bacc6">korensko urejanje</font>, kjer razporejamo elemente v koše glede na števke v primeru števil (in črke v primeru nizov). Nize lahko razdelimo v koše glede na njihovo prvo črko, nato pa posamezen koš uredimo po enakem postopku, samo da sedaj delimo v koše glede na drugo črko itd. Ko so koši urejeni, rezultate enostavno zložimo nazaj skupaj (poglej si animacijo). Časovna zahtevnost je tako $O(nd)$, če je $d$ dolžina največjega niza, enako pa velja za prostorsko zahtevnost (v resnici, je zraven še faktor $a$ - velikost abecede, samo da je ta konstanten v večini primerov).

Zakaj to delamo? Da lahko implementiramo, <font color="#4bacc6">binary search</font> (dvojiško iskanje - <font color="#4bacc6">bisekcija</font>) seveda: s časovno zahtevnostjo $O(\log n)$. 

### Abstraktni podatkovni tipi

1. <font color="#4bacc6">polje (array): </font>hrani urejen nabor elementov, do katerih dostopamo s celoštevilskimi indeksi, hrani podatke enakega tipa/velikosti zaporedno enega za drugim v strnjenem kosu pomnilnika.
2. <font color="#4bacc6">sklad (stack):</font> hrani elemente organizirane tako, da lahko dodamo nov element, dostopamo pa lahko samo do tistega, ki je bil dodan nazadnje, za njegovo implementacijo se uporabi povezan seznam, s katerim dosežemi konstantno časovno zahtevnost operacij.
3. <font color="#4bacc6">seznam (list):</font> podobno kot array, samo da lahko hrani različne tipe podatkov.
4. <font color="#4bacc6">povezani seznam (linked list):</font> omogoča učinkovito vsavljanje in brisanje preko kazalcev na elemente.
5. <font color="#4bacc6">dinamično polje (dynamic/resizeable array):</font> je "nadgradnja" osnovnega array-a, ki omogoča dodajanje novih elementov, kjer zaradi časovne zahtevnosti, ki bi jo prinesel array velikosti $n$ vsakič ko bi dodali nov element, se ustvari array z velikostjo (npr.) $2n$, kjer glede na določene faktorje potem malokrat dejansko kopiramo elemente polja v večjega (ali manjšega).
6. <font color="#4bacc6">vrsta (queue):</font> hrani elemente organizirane tako, da lahko dodamo nov element na konec vrste, dostopamo pa lahko do tistega, ki se nahaja na začetku vrste, torej FIFO (first in, first out). Lahko imamo tudi različico z dvema koncema, kjer lahko dodajamo in odstranjujemo z obeh strani. Lahko jo implementiramo s povezanim seznamom, vse operacije imajo tako konstantno časovno zahtevnost, prostorska zahtevnost pa je linearna.
7. <font color="#4bacc6">vrsta s prednostjo (priority queue):</font> podobna navadni vrsti, le da ima vsak element prirejeno tudi prioriteto, ko odstranjujemo elemente iz vrste, prejmemo najprej tistega z največjo (ali najmanjšo) prioiriteto in ne prvega, ki je bil vstavljen. 
8. <font color="#4bacc6">kopica (heap):</font> tipična učinkovita implementacija prioritetne vrste. Obstaj več vrst, mi obravnavamo le dvojiško kopico, za katero velja, da je zgrajena iz poravnanega dvojiškega drevesa, vsako vozlišče pa mora biti manjše ali enako od svojih otrok (oziroma obratno v primeru max-heap). Najmanjši element se tako nahaja v korenu drevesa, višina drevesa pa je $O(\log n)$. Zaradi svoje strukture jo lahko predstavimo kar s tabelo (kjer zaradi enostavnosti začnemo z indeksom 1 in ne 0), kjer velja da ima vozlišče $i$ na indeksu $2i$ in $2i+1$ svoja otroka in obratno svojega starša na indeksu $i / 2$ (zaokroženo navzdol). Nov element vstavimo na prvo prosto mesto, s čimer smo pokvarili urejenost, ki pa jo popravimo, tako delamo menjave s starši, dokler ne pride na ustrezno mesto, ali pa ne pride do korena. Prostorska zahtevnost je linearna, časovna zahtevnost obeh operacij pa sorazmerna z višino kopice, torej $O(\log n)$. S Floydovim algoritmom lahko kopico zgradimo v $O(n)$ času.
9. <font color="#4bacc6">preskočni seznam (skip list):</font> vsako vozlišče ima svojo "višino", ki je izbrana naključno. Vsak nov nivo pa je dodan z verjetnostjo $p$, ki je običajno $0.5$. Pričakovana prostorska zahtevnost je linearna $O(n)$, časovna zahtevnost vstavljanja ali iskanja posameznega elementa pa $O(\log n)$. 
10. <font color="#4bacc6">množica (set):</font> hrani množico elementov, ki ne predpisuje vrstnega reda elementov.
11. <font color="#4bacc6">slovar (map):</font> hrani pare - ključ, vrednost - pri tem pa se vsak ključ lahko pojavi največ enkrat, vsakemu ključu pa je prirejena neka vrednost.
12. <font color="#4bacc6">zgoščena/razpršena tabela (hash map):</font> temelji na zgoščevalni funkciji, ki preslika ključ kot indeks v tabelo določene velikosti, preslikavi različnih elementov v enako vrednost pravimo $trk$, katerih želimo čim manj, a vseeno jih potrebujemo obvladovati z veriženjem. Običajno merimo zasedenost tabele kot razmerje med številom vnesenih elementov in kapaciteto tabele, $\alpha = \frac{n}{H}$, ko ta faktor preseže določeno vrednost (če bi bilo to ena, bi pomenilo, da vedno pride do trka) lahko izvedemo ponovno zgoščevanje, kjer alociramo npr. dvakrat večjo tabelo in izračunamo nove vrednosti. V primeru da iščemo element, ki ne obstaja je pričakovana časovna zahtevnost enaka pričakovani dolžini seznama, torej $\alpha$, če poskrbimo da bo ta faktor neka konstantna vrednost, bo torej pričakovana časovna zahtevnost $O(1)$.

### Drevesne strukture

1. <font color="#4bacc6">vrste dreves: </font>
	1. dvojiška, kjer ima vsako vozlišče dva otroka, bolj splošno je $k$-tiško drevo,
	2. polno, ima v vsakem vozlišču maksimalno število otrok ali nobenega, npr. v dvojiškem drevesu ni vozlišča z le enim otrokom.
	3. popolno, so polna drevesa in vsebujejo maksimalno število vozlišč glede na višino drevesa
	4. urejena in neurejena
	5. iskalna, ki so urejena drevesa, v katerih velja, da vsebuje prvi otrok v svojem poddrevesu najmanjše vrednosti, drugi malo večje itd.
	6. črkovna/znakovna drevesa (trie)
2. <font color="#4bacc6">predstavitev dreves:</font> povezave do otrok in do starša ponavadi hranimo kot kazalce do njih, elemente vstavljamo rekurzivno, izbrišemo pa jih, če nima otrok ga preprosto odstranimo, če ima samo enega otroka, ga preprosto zamenjamo z njim, če ima pa oba otroka, pa ga zamenjamo z naslednjim večjim vozliščem (to je vozlišče, ki je najbolj levo v desnem poddrevesu, tega pa le preprosto odstranimo, saj zagotovo nima otroka), včasih lahko tudi pogoljufamo in se delamo da tega vozlišča preprosto ni.
3. <font color="#4bacc6">poizvedba na območjih (na statičnih drevesih):</font>
	1. vsota: pripravimo si tabelo kumulativnih vsot od začetka tabele in ju za poljubna elementa samo odštejemo.
	2. minimum: s statičnim drevesom, kjer imamo v vsakem korenu poddrevesa najmanjšo vrednost tega poddrevesa.
4. <font color="#4bacc6">uravnotežena drevesa:</font>
	1. AVL drevo: 