### Napredno urejanje

1. <font color="#4bacc6">merge sort: </font>razdeli elemente seznama na prvo in drugo polovico, rekurzivno uredi vsako polovico na enak način, nato pa združi dva urejena seznama v skupen urejen seznam. Globina rekurzije je $O(\log n)$, ker sezba vsakič razdelimo na pol, za posamezen nivo pa potrebujemo $O(n)$ časa za združevanje. <font color="#4bacc6">Časovna zahtevnost</font> je zato vedno $O(n \log n)$. Da zmanjšamo prostorsko zahtevnost lahko uporabimo le pomožno tabelo za indekse in ne delamo kopij tabele.
2. <font color="#4bacc6">quick sort: </font>ta razdeli elemente seznama na majhne in velike, majhne da na začetek seznama, velike pa na konec, za število po katerem ločujemo izberemo naključen $pivot$, npr. prvi element seznama. Nato gremo čez seznam in delimo elemente seznama v tri skupine: manjše, večje in enake pivotu. V najslabšem primeru pridemo tako do $O(n^2)$ <font color="#4bacc6">časovne zahtevnosti</font>, a je še vedno v povprečju ta enaka $O(\log n)$. Prostorska zahtevnost pa je odvisna od implementacije od $O(\log n)$ do $O(n)$.
3. <font color="#4bacc6">heap sort: </font> ... izboljšava navadnega urejanja z izbiranjem, le da vedno znova iščeš najmanjši element samo med neurejenimi, ... (heap)
4. <font color="#4bacc6">counting sort: </font>ko imaš nabor različnih možnosti, ki ni velik (npr. poštne številke), kjer za vsako vrednost preštejemo kolikokrat se uporabi in jo na koncu temu primerno večkrat vnesemo v urejen seznam. Časovna zahtevnost je linearna ozr. $O(n + m)$, kjer je $m$ največja možna vrednost, neugodna pa je prostorska zahtevnost.
5. <font color="#4bacc6">bucket/bin sort</font> (mi pogledamo <font color="#4bacc6">radix sort</font>): osnovna ideja je, da razdeliš elemente seznama v koše glede na njihovo vrednost in rekurzivno dobimo nekaj podobnega $quicksortu$. Pogledamo si $radix \ sort$ ozr. <font color="#4bacc6">korensko urejanje</font>, kjer razporejamo elemente v koše glede na števke v primeru števil (in črke v primeru nizov). Nize lahko razdelimo v koše glede na njihovo prvo črko, nato pa posamezen koš uredimo po enakem postopku, samo da sedaj delimo v koše glede na drugo črko itd. Ko so koši urejeni, rezultate enostavno zložimo nazaj skupaj (poglej si animacijo). Časovna zahtevnost je tako $O(nd)$, če je $d$ dolžina največjega niza, enako pa velja za prostorsko zahtevnost (v resnici, je zraven še faktor $a$ - velikost abecede, samo da je ta konstanten v večini primerov).

Zakaj to delamo? Da lahko implementiramo, <font color="#4bacc6">binary search</font> (dvojiško iskanje - <font color="#4bacc6">bisekcija</font>) seveda: s časovno zahtevnostjo $O(\log n)$ 